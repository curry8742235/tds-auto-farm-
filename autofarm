-- // ========================================================== //
-- //      TDS OPTIMIZED LIBRARY - DEEPSEEK EDITION v2           //
-- //      (Auto-Anchor, Terrain Snap, Anti-Road, Spiral Search) //
-- // ========================================================== //

-- // 1. CONFIGURATION
getgenv().AutoStrat = true
getgenv().AutoSkip = true 
getgenv().AutoPickups = true
getgenv().Webhook = "" 

-- // 2. LIBRARY INITIALIZATION
local TDS = {}
TDS.placed_towers = {}
TDS.Services = {
    Workspace = game:GetService("Workspace"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService")
}
TDS.LocalPlayer = TDS.Services.Players.LocalPlayer
TDS.Remote = TDS.Services.ReplicatedStorage:WaitForChild("RemoteFunction")

-- // 3. MAP ANALYSIS ENGINE
local MapEngine = {}
MapEngine.RecAnchor = Vector3.new(-48.8, 3.8, 14.5) -- Simplicity Spawn
MapEngine.CurrentAnchor = Vector3.zero
MapEngine.Offset = Vector3.zero

function MapEngine:WaitForMap()
    if not TDS.Services.Workspace:FindFirstChild("Map") then
        TDS.Services.Workspace.ChildAdded:Wait()
        task.wait(1)
    end
end

function MapEngine:GetPosition(obj)
    if not obj then return nil end
    if obj:IsA("BasePart") then return obj.Position end
    if obj:IsA("Model") or obj:IsA("Folder") then
        -- Priority: "0", "1", "Start", or First Part
        local p = obj:FindFirstChild("0") or obj:FindFirstChild("1") or obj:FindFirstChild("Start") or obj:FindFirstChildWhichIsA("BasePart")
        if p and p:IsA("BasePart") then return p.Position end
        -- Deep Search
        for _, c in ipairs(obj:GetChildren()) do
            if c:IsA("BasePart") then return c.Position end
        end
    end
    return nil
end

function MapEngine:FindAnchor()
    local map = TDS.Services.Workspace:FindFirstChild("Map")
    if not map then return Vector3.zero end

    -- 1. Check EnemySpawn
    if map:FindFirstChild("EnemySpawn") then return map.EnemySpawn.Position end

    -- 2. Check Paths Folder
    local paths = map:FindFirstChild("Paths")
    if paths then
        local targets = {"0", "1", "Path", "Path1", "Main"}
        for _, t in ipairs(targets) do
            local found = self:GetPosition(paths:FindFirstChild(t))
            if found then return found end
        end
    end
    
    return Vector3.zero
end

function MapEngine:ScanTerrain(x, z)
    local origin = Vector3.new(x, self.CurrentAnchor.Y + 100, z)
    local dir = Vector3.new(0, -500, 0)
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {
        TDS.LocalPlayer.Character,
        TDS.Services.Workspace:FindFirstChild("Towers"),
        TDS.Services.Workspace:FindFirstChild("Pickups"),
        TDS.Services.Workspace:FindFirstChild("Camera")
    }

    local result = TDS.Services.Workspace:Raycast(origin, dir, params)
    if result and result.Instance then
        local hit = result.Instance
        local n = hit.Name
        local p = hit.Parent.Name
        
        -- STRICT FILTER: IGNORE BAD SURFACES
        if n == "Road" or p == "Road" or hit.Parent.Parent.Name == "Road" then return nil end
        if n == "Path" or p == "Paths" or hit.Parent.Parent.Name == "Paths" then return nil end
        if n == "Bridge" or n == "Cliff" or p == "Cliff" then return nil end
        if n == "Boundaries" or p == "Boundaries" then return nil end
        
        -- Return valid ground height + offset
        return result.Position.Y + 0.2
    end
    return nil
end

function MapEngine:Initialize()
    self:WaitForMap()
    self.CurrentAnchor = self:FindAnchor()
    
    if self.CurrentAnchor == Vector3.zero then
        warn("[Library] ⚠️ CRITICAL: Could not find Map Anchor. Defaulting to 0,0,0.")
    else
        self.Offset = self.CurrentAnchor - self.RecAnchor
        print("[Library] ✅ Map Adapted. Offset:", self.Offset)
    end
end

-- Initialize the Engine immediately
MapEngine:Initialize()

-- // 4. LIBRARY FUNCTIONS

-- [OPTIMIZED PLACE FUNCTION]
function TDS:Place(name, recX, recY, recZ)
    local baseX = recX + MapEngine.Offset.X
    local baseZ = recZ + MapEngine.Offset.Z
    
    -- SEARCH PARAMETERS
    local RADIUS = 30
    local STEP = 3.5
    
    -- 1. Attempt exact relative position first (Radius 0)
    -- 2. Spiral out to find valid ground
    for r = 0, RADIUS, STEP do
        local points = (r == 0) and 1 or math.floor((2 * math.pi * r) / STEP)
        
        for i = 1, points do
            local angle = (math.pi * 2 / points) * i
            local tryX = baseX + (math.cos(angle) * r)
            local tryZ = baseZ + (math.sin(angle) * r)
            
            -- Raycast to find floor height (and ensure it's not a road)
            local validY = MapEngine:ScanTerrain(tryX, tryZ)
            
            if validY then
                local targetPos = Vector3.new(tryX, validY, tryZ)
                
                local success, result = pcall(function()
                    return self.Remote:InvokeServer("Troops", "Place", {
                        Rotation = CFrame.new(),
                        Position = targetPos
                    }, name)
                end)
                
                if success and (result == true or (type(result)=="table" and result.Success)) then
                    -- Verify Placement
                    local startT = tick()
                    repeat task.wait() until tick() - startT > 1 or #TDS.Services.Workspace.Towers:GetChildren() > #self.placed_towers
                    
                    -- Find the new tower
                    for _, t in ipairs(TDS.Services.Workspace.Towers:GetChildren()) do
                        if t.Name == name and t.Owner.Value == TDS.LocalPlayer.UserId then
                            local isTracked = false
                            for _, known in ipairs(self.placed_towers) do
                                if known == t then isTracked = true break end
                            end
                            
                            if not isTracked then
                                table.insert(self.placed_towers, t)
                                print(string.format("✅ [Library] Placed %s (R: %.1f)", name, r))
                                return -- EXIT FUNCTION UPON SUCCESS
                            end
                        end
                    end
                end
            end
        end
    end
    warn(string.format("❌ [Library] Failed to place %s (Checked %d studs radius)", name, RADIUS))
end

function TDS:Upgrade(idx)
    local t = self.placed_towers[idx]
    if not t then return end
    pcall(function() self.Remote:InvokeServer("Troops", "Upgrade", "Set", { Troop = t, Path = 1 }) end)
end

function TDS:Skip()
    pcall(function() self.Remote:InvokeServer("Voting", "Skip") end)
end

function TDS:AutoChain(...)
    -- Placeholder for chain logic if needed
end

-- // 5. BACKGROUND TASKS (Optimized)
task.spawn(function()
    while task.wait(1) do
        if getgenv().AutoSkip then
            local vote = TDS.LocalPlayer.PlayerGui:FindFirstChild("ReactOverridesVote")
            if vote and vote:FindFirstChild("Frame") and vote.Frame.Visible then
                TDS:Skip()
            end
        end
    end
end)

print("--- TDS LIBRARY INITIALIZED ---")

-- // ========================================== //
-- //      STRATEGY EXECUTION SECTION            //
-- // ========================================== //

TDS:Place("Scout", -18.16, 1.00, -2.36) -- 1
TDS:Place("Scout", -18.17, 1.00, -5.55) -- 2
TDS:Place("Scout", -18.19, 1.00, -8.74) -- 3
TDS:Place("Scout", -14.89, 1.00, -9.23) -- 4
TDS:Place("Scout", -17.18, 1.00, -11.71) -- 5
TDS:Place("Scout", -19.92, 1.00, -13.37) -- 6
TDS:Place("Scout", -17.09, 1.00, -14.89) -- 7
TDS:Place("Scout", -14.19, 1.00, -12.89) -- 8
TDS:Place("Scout", -11.89, 1.00, -10.53) -- 9
TDS:Place("Scout", -11.78, 1.00, -3.17) -- 10
TDS:Place("Scout", -8.58, 1.00, -2.99) -- 11
TDS:Place("Scout", -11.85, 1.00, 0.04) -- 12
TDS:Place("Scout", -8.53, 1.00, 0.17) -- 13
TDS:Place("Scout", -11.81, 1.00, 3.27) -- 14
TDS:Place("Scout", -8.53, 1.00, 3.45) -- 15
TDS:Place("Scout", -14.97, 1.00, 3.62) -- 16
TDS:Place("Scout", -18.32, 1.00, 3.66) -- 17
TDS:Place("Scout", -21.56, 1.00, 3.69) -- 18
TDS:Place("Scout", -21.55, 1.00, 7.07) -- 19
TDS:Place("Scout", -18.18, 1.00, 7.07) -- 20
TDS:Place("Scout", -14.82, 1.00, 6.91) -- 21
TDS:Place("Scout", -11.70, 1.00, 6.73) -- 22
TDS:Place("Scout", -8.36, 1.00, 6.84) -- 23
TDS:Place("Scout", -5.36, 1.00, -3.08) -- 24
TDS:Place("Scout", -8.55, 1.00, -9.23) -- 25
TDS:Place("Scout", -4.77, 1.00, -9.17) -- 26
TDS:Place("Scout", -2.12, 1.00, -3.02) -- 27
TDS:Place("Scout", -1.53, 1.00, -9.31) -- 28
TDS:Place("Scout", -24.45, 1.00, -5.66) -- 29
TDS:Place("Scout", -24.49, 1.00, -2.38) -- 30
TDS:Place("Scout", -24.47, 1.00, 1.04) -- 31
TDS:Place("Scout", -24.80, 1.00, 4.40) -- 32
TDS:Place("Scout", -27.41, 1.00, -7.94) -- 33
TDS:Place("Scout", -27.25, 1.00, -11.07) -- 34
TDS:Place("Scout", -1.83, 1.00, 3.27) -- 35
TDS:Place("Scout", 1.25, 1.00, -3.35) -- 36
TDS:Place("Scout", 4.46, 1.00, -3.42) -- 37
TDS:Place("Scout", 1.42, 1.00, 3.43) -- 38
TDS:Place("Scout", 5.39, 1.00, 3.24) -- 39
TDS:Place("Scout", 6.56, 1.00, -7.08) -- 40

-- Max Upgrade Loop
for lvl = 1, 4 do
    for i = 1, 40 do TDS:Upgrade(i) end
    task.wait(1.5)
end
