-- // CONFIGURATION 
getgenv().AutoStrat = true
getgenv().AutoSkip = true 
getgenv().AutoPickups = true
getgenv().Webhook = "" 

-- // 1. LOAD LIBRARY
local libURL = "https://gist.githubusercontent.com/curry8742235/38ad26d4b4b3373a9b7b21bf59d14015/raw/85d4d1a32dd0f37fb9e2766bcaf97480cdf121c7/library"
local success, TDS = pcall(function() return loadstring(game:HttpGet(libURL))() end)

if not success or not TDS then
    warn("Gist failed, using backup library...")
    TDS = loadstring(game:HttpGet("https://raw.githubusercontent.com/DuxiiT/auto-strat/refs/heads/main/Library.lua"))()
end

if not TDS then return warn("CRITICAL: Library failed to load.") end

-- // 2. SMART MAP ANALYSIS
local Workspace = game:GetService("Workspace")
local RemoteFunc = game:GetService("ReplicatedStorage"):WaitForChild("RemoteFunction")
local LocalPlayer = game:GetService("Players").LocalPlayer

-- Helper to get position from any Instance
local function GetPos(obj)
    if not obj then return nil end
    if obj:IsA("BasePart") then return obj.Position end
    if obj:IsA("Model") or obj:IsA("Folder") then
        local p = obj:FindFirstChild("0") or obj:FindFirstChild("1") or obj:FindFirstChildWhichIsA("BasePart")
        if p then return p.Position end
        -- Dig deeper
        for _, c in ipairs(obj:GetChildren()) do
            if c:IsA("BasePart") then return c.Position end
        end
    end
    return nil
end

-- Find the Start of the Path (Anchor)
local function GetMapAnchor()
    local map = Workspace:FindFirstChild("Map")
    if not map then return Vector3.zero end

    -- Priority 1: EnemySpawn
    if map:FindFirstChild("EnemySpawn") then return map.EnemySpawn.Position end

    -- Priority 2: Lowest Numbered Path Node
    local paths = map:FindFirstChild("Paths")
    if paths then
        -- Find the lowest numbered child (e.g. "1" or "0")
        local lowest = 999
        local bestNode = nil
        
        for _, child in ipairs(paths:GetChildren()) do
            local num = tonumber(child.Name)
            if num and num < lowest then
                lowest = num
                bestNode = child
            end
        end
        
        if bestNode then return GetPos(bestNode) end
        
        -- Fallback: Look for "Path" or "Start"
        return GetPos(paths:FindFirstChild("Path")) or GetPos(paths:FindFirstChild("Start"))
    end
    
    return Vector3.zero
end

-- Raycast to find VALID GROUND (Grass) vs INVALID (Road/Cliff)
local function ScanTerrain(x, z, startY)
    local origin = Vector3.new(x, startY + 100, z)
    local dir = Vector3.new(0, -500, 0)
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {
        LocalPlayer.Character, 
        Workspace:FindFirstChild("Towers"), 
        Workspace:FindFirstChild("Pickups"),
        Workspace:FindFirstChild("Camera")
    }

    local res = Workspace:Raycast(origin, dir, params)
    if res and res.Instance then
        local hit = res.Instance
        local hitName = hit.Name
        local parentName = hit.Parent.Name
        
        -- REJECT ROADS AND CLIFFS (For Ground Units)
        if hitName == "Road" or hitName == "Boundaries" or hitName == "Path" or hitName == "Bridge" then return nil end
        if parentName == "Road" or parentName == "Boundaries" or parentName == "Paths" then return nil end
        
        -- PREFER GROUND
        -- We accept it if it's not a road.
        -- We lift it slightly (0.5 studs) to prevent clipping
        return res.Position.Y
    end
    return nil
end

-- Setup Offset
local RecAnchor = Vector3.new(-48.8, 3.8, 14.5)
local CurAnchor = GetMapAnchor()
local MapOffset = (CurAnchor.Magnitude > 0) and (CurAnchor - RecAnchor) or Vector3.zero

print("[DeepSeek] Map Anchor Detected:", CurAnchor)
print("[DeepSeek] Offset:", MapOffset)

-- // 3. OVERWRITE PLACE FUNCTION (Spiral Search + Anti-Road)
TDS.Place = function(self, name, recX, recY, recZ)
    local baseX = recX + MapOffset.X
    local baseZ = recZ + MapOffset.Z
    
    -- Search Radius: 0 to 25 Studs
    local maxRadius = 25
    local step = 3
    
    for r = 0, maxRadius, step do
        local pts = (r==0) and 1 or math.floor((2*math.pi*r)/3)
        for i=1, pts do
            local ang = (math.pi*2/pts) * i
            local tx = baseX + math.cos(ang)*r
            local tz = baseZ + math.sin(ang)*r
            
            -- CHECK GROUND
            local groundY = ScanTerrain(tx, tz, CurAnchor.Y)
            
            if groundY then
                local target = Vector3.new(tx, groundY + 0.5, tz)
                
                -- ATTEMPT PLACE
                local success, res = pcall(function()
                    return RemoteFunc:InvokeServer("Troops", "Place", {
                        Rotation = CFrame.new(),
                        Position = target
                    }, name)
                end)

                -- VERIFY
                if success and (res == true or (type(res)=="table" and res.Success)) then
                    task.wait(0.2)
                    -- Check if tower exists in workspace owned by us
                    for _, t in ipairs(Workspace.Towers:GetChildren()) do
                        if t.Name == name and t.Owner.Value == LocalPlayer.UserId then
                            -- Ensure we haven't tracked this one yet
                            local isNew = true
                            for _, known in ipairs(self.placed_towers) do
                                if known == t then isNew = false break end
                            end
                            
                            if isNew then
                                table.insert(self.placed_towers, t)
                                print("✅ PLACED:", name, "| Radius:", r)
                                return -- DONE
                            end
                        end
                    end
                end
            end
        end
    end
    warn("❌ FAILED:", name, "- No valid ground found nearby.")
end

print("--- ADAPTIVE STRAT LOADED ---")

-- // 4. STRATEGY
TDS:Place("Scout", -18.16, 1.00, -2.36)
TDS:Place("Scout", -18.17, 1.00, -5.55)
TDS:Place("Scout", -18.19, 1.00, -8.74)
TDS:Place("Scout", -14.89, 1.00, -9.23)
TDS:Place("Scout", -17.18, 1.00, -11.71)
TDS:Place("Scout", -19.92, 1.00, -13.37)
TDS:Place("Scout", -17.09, 1.00, -14.89)
TDS:Place("Scout", -14.19, 1.00, -12.89)
TDS:Place("Scout", -11.89, 1.00, -10.53)
TDS:Place("Scout", -11.78, 1.00, -3.17)
TDS:Place("Scout", -8.58, 1.00, -2.99)
TDS:Place("Scout", -11.85, 1.00, 0.04)
TDS:Place("Scout", -8.53, 1.00, 0.17)
TDS:Place("Scout", -11.81, 1.00, 3.27)
TDS:Place("Scout", -8.53, 1.00, 3.45)
TDS:Place("Scout", -14.97, 1.00, 3.62)
TDS:Place("Scout", -18.32, 1.00, 3.66)
TDS:Place("Scout", -21.56, 1.00, 3.69)
TDS:Place("Scout", -21.55, 1.00, 7.07)
TDS:Place("Scout", -18.18, 1.00, 7.07)
TDS:Place("Scout", -14.82, 1.00, 6.91)
TDS:Place("Scout", -11.70, 1.00, 6.73)
TDS:Place("Scout", -8.36, 1.00, 6.84)
TDS:Place("Scout", -5.36, 1.00, -3.08)
TDS:Place("Scout", -8.55, 1.00, -9.23)
TDS:Place("Scout", -4.77, 1.00, -9.17)
TDS:Place("Scout", -2.12, 1.00, -3.02)
TDS:Place("Scout", -1.53, 1.00, -9.31)
TDS:Place("Scout", -24.45, 1.00, -5.66)
TDS:Place("Scout", -24.49, 1.00, -2.38)
TDS:Place("Scout", -24.47, 1.00, 1.04)
TDS:Place("Scout", -24.80, 1.00, 4.40)
TDS:Place("Scout", -27.41, 1.00, -7.94)
TDS:Place("Scout", -27.25, 1.00, -11.07)
TDS:Place("Scout", -1.83, 1.00, 3.27)
TDS:Place("Scout", 1.25, 1.00, -3.35)
TDS:Place("Scout", 4.46, 1.00, -3.42)
TDS:Place("Scout", 1.42, 1.00, 3.43)
TDS:Place("Scout", 5.39, 1.00, 3.24)
TDS:Place("Scout", 6.56, 1.00, -7.08)

for lvl = 1, 4 do
    for i = 1, 40 do TDS:Upgrade(i) end
    task.wait(1.5)
end
